* Add TinyMaps

Add tiny maps between tiny sets, complete with id(s), cod(f), dom(f),
and f == g if f and g are the same map as parts of 8.

Identify the elements of A that correspond to the elements 1, 2, ...,
8 of 8 with maps f : 1 -> A. If this works out.

Could f[3] == 5 or f(3) == 5 work? With 3 in dom(f), 5 in cod(f), or
it would be a type error.

No set operations on maps. Maps are not sets. But composition! Also
with generalized-element syntax, f(g). Might also be able to use sets
themselves as their identity maps.

Then again, inclusion maps could be considered as parts, and should,
so there would be set operations on them.

And generate all left and right inverses.

A TinyMap can be easily packed in 64 bits: 8 for dom, 8 for cod, 3 for
each of the maximum 8 values, and there are a spare 16 bits even with
using 4 bits per value.

* Reconsider string syntax and more

First draft has string syntax macros for tiny sets and relations.
Remove those. They are awkward as they are, they reveal implementation
details - do they not - and for tiny maps they seem even more awkward.

Or is it even so that the first draft is all wrong? Does it make tiny
sets abstract sets where they should be considered to have structure
as parts of 8? Must make them right. Maybe they are - must make sure.

But give up on string syntax altogether, anyway.

tinyset(3,1,4) or canonically tinyset(1,3,4) to denote {1,3,4}
tinyset() is {}

tinymap(tinyset(3,1,4), 2=>3, 3=>3, 1=>1)
has domain {1,2,3} collected from the mapping
has codomain {1,3,4} given explicitly - optional for an epimap?

tinymap(tinyset(3,1))
has domain tinyset()

tinyrel(1=>5, 1=>3, 3=>2)
tinyrel()
do these need domain and codomain (in another category) or at least
explicitly the parts of eight whose product they are part of? seems so

* Start again from scratch

When thinking of syntax for individual tiny sets and relations and
whether relations need something like explicit domain and codomain,
doubts began to be doubted.

Does this actually mean rewriting everything from scratch? Current
draft has TinyPart{N} as a part of an N-element abstract set, and
TinyRelation{N} as a relation on an N-element abstract set, or perhaps
something even less useful, or is that useful? Whereas parts of 8
could be parts of each other in a well-defined way, by reference to
that 8, and interesting in their own right. So this does mean actually
rewriting everything from scratch.

Hm yes, current situation is before tiny maps, so the same bit
patterns have been considered as canonical inclusions and there has
been no way to to refer to other inclusions, or something like that.

The new way should be better. Not only different but also better, with
more to explore. Also, something like a known category (parts of 8) to
explore instead of exploring an accidental and less promising system.

Oh yes - parts of {1,3,4}, for example, form the same lattice as the
parts of the more canonical {1,2,3}, and the new way provides both! Go
for it! Eschew awkward!

And then there would be relations from A to B for all parts A, B of 8,
and not just relations on (a canonical form of) A. Mere bits types may
not be sufficient any more, or not as easy to use, but that was surely
the least interesting detail. Was it?

* Like this

Each TinySet is a part of top(8), an eight-element abstract set with
canonically named elements 1,2,3,...,8 identified with maps from the
canonical terminal set top(1).

Should that top(1) be can(1), for "canonical" 1-part (of 8)? Maybe.
But then there should be can(A) for any tiny set A. And for any tiny
relation R. Or is can(A) rather a canonical isomorphism that takes A
to a canonical object and can then be composed with maps, too? Maybe.

All 256 parts of 8 are generated by eachpart(top(8)) where top(8) is
shorthand for tinyset(1,2,3,4,5,6,7,8).

Some parts of 8 double as parts of 7, 6, ... in the sense that they
can be generated by eachpart(top(7)), eachpart(top(6)), ...

Other parts of, say, 4, can be generated by eachpart(tinyset(2,4,5,6))
and there are inclusion maps, but this needs thought.

Similarly, to generate a random part of top(N), randset(top(N)), and
from any a tiny set A, randset(A).

There are canonical inclusions, tinymap(top(3), top(8)),
tinymap(tinyset(1,2,3), top(8)) as inclusions to top(8),
tinymap(top(3), top(5)), tinymap(tinyset(1,2,3), tinyset(1,2,3,4,5))
to top(5), and generally.

Then there are identity maps id(A).

Then there are the universal maps tinymap(top(0), A) for any A and
tinymap(A, top(1)) also for any A.

The ambiguity is not real, because tinymap(top(0), A) is the canonical
inclusion when A is a canonical part, and tinymap(A, top(1)) is the
canonical inclusion when A is 1.

A TinyMap can be given explicitly. Its codomain needs to be specified,
while the domain is implicit in the listing. For example, the domain
of tinymap(top(4), 3=>1, 1=>2, 4=>3) is tinyset(1,3,4) for which the
mapping is listed, while the codomain is the given tinyset(1,2,3,4).

eachmap(A, B) ; also eachmono(A, B), eachepi(A, B)
randmap(A, B) ; also randmono(A, B), randepi(A, B)

eachpoint(A) -- same as eachmap(top(1), A) but makes a point or two
randpoint(A) -- likewise

Maps compose. Maps can be factored. Maps can have sections and
retractions. Oh, and maps have domain and codomain, of course.

A TinyRelation from a TinySet A to a TinySet B is a part of A тип B with
canonical projections or something like that. Is a part of a canonical
product, maybe.

Hm must can construct each A тип B canonically as a part of a canonical
8 тип 8, is that possible and makes sense? Moving from parts of 8 to
parts of 8 тип 8 and back, like?

eachrelation(A, B) ; eachorder(A, B)
randrelation(A, B) ; eachorder(A, B)

tinyrelation(A, B, 3=>1, 3=>2, 1=>4)

Maybe diagrelation(A)? and diag(R)::TinySet? Or what?

Transpose, opposite relation? Relations also compose. Do they have
(canonical) inclusions?

* Relations of parts

There are subset relations between parts of a set, but then the parts
are taken to be specific inclusion maps. Go this way for tiny sets.

Determines, is determined by, factors through, all that ETCS. For
generalized elements, too.

And go this way also for parts of the product, the tiny relations.

Keep equality concrete. Define equivalence of parts separately.
* Plan

Add TinySet. Eight bits, points 1 << (k - 1) for k = 1, ..., 8, nine
canonical sets can(0), can(1), ..., can(8) have that many least bits
set, what else? Start with this.

Add TinyMap.

Adapt lattice test.

Make them rich.

Then consider the fate of old TinyPart{N}, TinyRelation{N}.

Then introcude new tiny relations.

Finish. Polish.
